// Code generated by "./colgenerator"; DO NOT EDIT.

package clickhouse

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/ClickHouse/ch-go/proto"
	insaneJSON "github.com/vitkovskii/insane-json"
)

type InsaneColInput interface {
	proto.ColInput
	Append(node *insaneJSON.StrictNode) error
	Reset()
}

func insaneInfer(auto proto.ColAuto) (InsaneColInput, error) {
	t := strings.TrimSuffix(strings.TrimPrefix(auto.Type().String(), "Nullable("), ")")
	nullable := auto.Type().Base() == proto.ColumnTypeNullable
	switch proto.ColumnType(t) {
	{{- range $type := .Types }}
	case {{ printf "proto.ColumnType%s" $type.ChTypeName  }}:
		return New{{ $type.ColumnTypeName }}(nullable), nil
	{{- end }}
	default:
		return nil, fmt.Errorf("inference for type %s is not supported", auto.Type().String())
	}
}

var (
	ErrNodeIsNil = errors.New("node is nil, but column is not")
)

{{- range $type := .Types }}

type {{ $type.ColumnTypeName }} struct {
	{{- if $type.CannotBeNull }}
	col *{{ $type.LibChTypeNameFull }}
	{{- else }}
	col      *{{ $type.LibChTypeNameFull }}
	nullCol  *{{ $type.NullableTypeName }}
	nullable bool
	{{- end }}
}

var _ InsaneColInput = (*{{ $type.ColumnTypeName }})(nil)

func New{{- $type.ColumnTypeName }}(nullable bool) *{{ $type.ColumnTypeName }} {
	{{- if $type.CannotBeNull  }}
	return &{{ $type.ColumnTypeName }}{
		col: &{{ $type.LibChTypeNameFull }}{},
	}
	{{- else }}
	return &{{ $type.ColumnTypeName }}{
		col:      &{{ $type.LibChTypeNameFull }}{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[{{$type.GoName}}](&{{ $type.LibChTypeNameFull }}{})),
		nullable: nullable,
	}
	{{- end}}
}

func (t *{{ $type.ColumnTypeName }}) Append(node *insaneJSON.StrictNode) error {
	if node == nil || node.IsNull() {
		{{- if $type.CannotBeNull }}
		return ErrNodeIsNil
		{{- else }}
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[{{- $type.GoName }}]())
		return nil
		{{- end }}
	}
	{{ if $type.CannotConvert -}}
	val, err := node.{{- $type.InsaneConvertFunc }}()
	if err != nil {
		return err
	}
	{{ else -}}
	v, err := node.{{- $type.InsaneConvertFunc }}()
	if err != nil {
		return err
	}
	val := {{ $type.ConvertInsaneJSONValue "v" }}
	{{ end }}
	{{- if not $type.CannotBeNull -}}
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	{{ end -}}

	t.col.Append(val)

	return nil
}

func (t *{{ $type.ColumnTypeName }}) Reset() {
	t.col.Reset()
	{{- if not $type.CannotBeNull }}
	t.nullCol.Reset()
	{{- end }}
}

func (t *{{ $type.ColumnTypeName }}) Type() proto.ColumnType {
	{{- if $type.CannotBeNull }}
	return t.col.Type()
	{{- else }}
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
	{{- end }}
}

func (t *{{ $type.ColumnTypeName }}) Rows() int {
	{{- if $type.CannotBeNull }}
	return t.col.Rows()
	{{- else }}
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
	{{- end }}
}

func (t *{{ $type.ColumnTypeName }}) EncodeColumn(buffer *proto.Buffer) {
	{{- if $type.CannotBeNull }}
	t.col.EncodeColumn(buffer)
	{{- else }}
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
	{{- end }}
}
{{- end }}
