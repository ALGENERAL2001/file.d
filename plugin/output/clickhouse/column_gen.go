// Code generated by "./colgenerator"; DO NOT EDIT.

package clickhouse

import (
	"errors"
	"fmt"
	"strings"

	"github.com/ClickHouse/ch-go/proto"
	insaneJSON "github.com/vitkovskii/insane-json"
)

type InsaneColInput interface {
	proto.ColInput
	Append(node *insaneJSON.StrictNode) error
	Reset()
}

func insaneInfer(auto proto.ColAuto) (InsaneColInput, error) {
	t := strings.TrimSuffix(strings.TrimPrefix(auto.Type().String(), "Nullable("), ")")
	nullable := auto.Type().Base() == proto.ColumnTypeNullable
	switch proto.ColumnType(t) {
	case proto.ColumnTypeBool:
		return NewColBool(nullable), nil
	case proto.ColumnTypeString:
		return NewColStr(nullable), nil
	case proto.ColumnTypeEnum8:
		return NewColEnum8(nullable), nil
	case proto.ColumnTypeEnum16:
		return NewColEnum16(nullable), nil
	case proto.ColumnTypeInt8:
		return NewColInt8(nullable), nil
	case proto.ColumnTypeInt16:
		return NewColInt16(nullable), nil
	case proto.ColumnTypeInt32:
		return NewColInt32(nullable), nil
	case proto.ColumnTypeInt64:
		return NewColInt64(nullable), nil
	case proto.ColumnTypeInt128:
		return NewColInt128(nullable), nil
	case proto.ColumnTypeInt256:
		return NewColInt256(nullable), nil
	case proto.ColumnTypeUInt8:
		return NewColUInt8(nullable), nil
	case proto.ColumnTypeUInt16:
		return NewColUInt16(nullable), nil
	case proto.ColumnTypeUInt32:
		return NewColUInt32(nullable), nil
	case proto.ColumnTypeUInt64:
		return NewColUInt64(nullable), nil
	case proto.ColumnTypeUInt128:
		return NewColUInt128(nullable), nil
	case proto.ColumnTypeUInt256:
		return NewColUInt256(nullable), nil
	case proto.ColumnTypeFloat32:
		return NewColFloat32(nullable), nil
	case proto.ColumnTypeFloat64:
		return NewColFloat64(nullable), nil
	default:
		return nil, fmt.Errorf("inference for type %s is not supported", auto.Type().String())
	}
}

var (
	ErrNodeIsNil = errors.New("node is nil, but column is not")
)

type ColBool struct {
	col      *proto.ColBool
	nullCol  *proto.ColNullable[bool]
	nullable bool
}

var _ InsaneColInput = (*ColBool)(nil)

func NewColBool(nullable bool) *ColBool {
	return &ColBool{
		col:      &proto.ColBool{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[bool](&proto.ColBool{})),
		nullable: nullable,
	}
}

func (t *ColBool) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[bool]())
		return nil
	}
	val, err := node.AsBool()
	if err != nil {
		return err
	}
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColBool) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColBool) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColBool) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColBool) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColStr struct {
	col      *proto.ColStr
	nullCol  *proto.ColNullable[string]
	nullable bool
}

var _ InsaneColInput = (*ColStr)(nil)

func NewColStr(nullable bool) *ColStr {
	return &ColStr{
		col:      &proto.ColStr{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[string](&proto.ColStr{})),
		nullable: nullable,
	}
}

func (t *ColStr) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[string]())
		return nil
	}
	val, err := node.AsString()
	if err != nil {
		return err
	}
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColStr) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColStr) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColStr) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColStr) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColEnum8 struct {
	col *proto.ColEnum8
}

var _ InsaneColInput = (*ColEnum8)(nil)

func NewColEnum8(nullable bool) *ColEnum8 {
	return &ColEnum8{
		col: &proto.ColEnum8{},
	}
}

func (t *ColEnum8) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		return ErrNodeIsNil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := proto.Enum8(v)

	t.col.Append(val)

	return nil
}

func (t *ColEnum8) Reset() {
	t.col.Reset()
}

func (t *ColEnum8) Type() proto.ColumnType {
	return t.col.Type()
}

func (t *ColEnum8) Rows() int {
	return t.col.Rows()
}

func (t *ColEnum8) EncodeColumn(buffer *proto.Buffer) {
	t.col.EncodeColumn(buffer)
}

type ColEnum16 struct {
	col *proto.ColEnum16
}

var _ InsaneColInput = (*ColEnum16)(nil)

func NewColEnum16(nullable bool) *ColEnum16 {
	return &ColEnum16{
		col: &proto.ColEnum16{},
	}
}

func (t *ColEnum16) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		return ErrNodeIsNil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := proto.Enum16(v)

	t.col.Append(val)

	return nil
}

func (t *ColEnum16) Reset() {
	t.col.Reset()
}

func (t *ColEnum16) Type() proto.ColumnType {
	return t.col.Type()
}

func (t *ColEnum16) Rows() int {
	return t.col.Rows()
}

func (t *ColEnum16) EncodeColumn(buffer *proto.Buffer) {
	t.col.EncodeColumn(buffer)
}

type ColInt8 struct {
	col      *proto.ColInt8
	nullCol  *proto.ColNullable[int8]
	nullable bool
}

var _ InsaneColInput = (*ColInt8)(nil)

func NewColInt8(nullable bool) *ColInt8 {
	return &ColInt8{
		col:      &proto.ColInt8{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[int8](&proto.ColInt8{})),
		nullable: nullable,
	}
}

func (t *ColInt8) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[int8]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := int8(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColInt8) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColInt8) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColInt8) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColInt8) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColInt16 struct {
	col      *proto.ColInt16
	nullCol  *proto.ColNullable[int16]
	nullable bool
}

var _ InsaneColInput = (*ColInt16)(nil)

func NewColInt16(nullable bool) *ColInt16 {
	return &ColInt16{
		col:      &proto.ColInt16{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[int16](&proto.ColInt16{})),
		nullable: nullable,
	}
}

func (t *ColInt16) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[int16]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := int16(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColInt16) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColInt16) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColInt16) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColInt16) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColInt32 struct {
	col      *proto.ColInt32
	nullCol  *proto.ColNullable[int32]
	nullable bool
}

var _ InsaneColInput = (*ColInt32)(nil)

func NewColInt32(nullable bool) *ColInt32 {
	return &ColInt32{
		col:      &proto.ColInt32{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[int32](&proto.ColInt32{})),
		nullable: nullable,
	}
}

func (t *ColInt32) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[int32]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := int32(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColInt32) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColInt32) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColInt32) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColInt32) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColInt64 struct {
	col      *proto.ColInt64
	nullCol  *proto.ColNullable[int64]
	nullable bool
}

var _ InsaneColInput = (*ColInt64)(nil)

func NewColInt64(nullable bool) *ColInt64 {
	return &ColInt64{
		col:      &proto.ColInt64{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[int64](&proto.ColInt64{})),
		nullable: nullable,
	}
}

func (t *ColInt64) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[int64]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := int64(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColInt64) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColInt64) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColInt64) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColInt64) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColInt128 struct {
	col      *proto.ColInt128
	nullCol  *proto.ColNullable[proto.Int128]
	nullable bool
}

var _ InsaneColInput = (*ColInt128)(nil)

func NewColInt128(nullable bool) *ColInt128 {
	return &ColInt128{
		col:      &proto.ColInt128{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[proto.Int128](&proto.ColInt128{})),
		nullable: nullable,
	}
}

func (t *ColInt128) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[proto.Int128]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := proto.Int128FromInt(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColInt128) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColInt128) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColInt128) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColInt128) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColInt256 struct {
	col      *proto.ColInt256
	nullCol  *proto.ColNullable[proto.Int256]
	nullable bool
}

var _ InsaneColInput = (*ColInt256)(nil)

func NewColInt256(nullable bool) *ColInt256 {
	return &ColInt256{
		col:      &proto.ColInt256{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[proto.Int256](&proto.ColInt256{})),
		nullable: nullable,
	}
}

func (t *ColInt256) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[proto.Int256]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := proto.Int256FromInt(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColInt256) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColInt256) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColInt256) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColInt256) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColUInt8 struct {
	col      *proto.ColUInt8
	nullCol  *proto.ColNullable[uint8]
	nullable bool
}

var _ InsaneColInput = (*ColUInt8)(nil)

func NewColUInt8(nullable bool) *ColUInt8 {
	return &ColUInt8{
		col:      &proto.ColUInt8{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[uint8](&proto.ColUInt8{})),
		nullable: nullable,
	}
}

func (t *ColUInt8) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[uint8]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := uint8(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColUInt8) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColUInt8) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColUInt8) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColUInt8) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColUInt16 struct {
	col      *proto.ColUInt16
	nullCol  *proto.ColNullable[uint16]
	nullable bool
}

var _ InsaneColInput = (*ColUInt16)(nil)

func NewColUInt16(nullable bool) *ColUInt16 {
	return &ColUInt16{
		col:      &proto.ColUInt16{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[uint16](&proto.ColUInt16{})),
		nullable: nullable,
	}
}

func (t *ColUInt16) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[uint16]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := uint16(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColUInt16) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColUInt16) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColUInt16) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColUInt16) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColUInt32 struct {
	col      *proto.ColUInt32
	nullCol  *proto.ColNullable[uint32]
	nullable bool
}

var _ InsaneColInput = (*ColUInt32)(nil)

func NewColUInt32(nullable bool) *ColUInt32 {
	return &ColUInt32{
		col:      &proto.ColUInt32{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[uint32](&proto.ColUInt32{})),
		nullable: nullable,
	}
}

func (t *ColUInt32) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[uint32]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := uint32(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColUInt32) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColUInt32) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColUInt32) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColUInt32) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColUInt64 struct {
	col      *proto.ColUInt64
	nullCol  *proto.ColNullable[uint64]
	nullable bool
}

var _ InsaneColInput = (*ColUInt64)(nil)

func NewColUInt64(nullable bool) *ColUInt64 {
	return &ColUInt64{
		col:      &proto.ColUInt64{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[uint64](&proto.ColUInt64{})),
		nullable: nullable,
	}
}

func (t *ColUInt64) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[uint64]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := uint64(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColUInt64) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColUInt64) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColUInt64) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColUInt64) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColUInt128 struct {
	col      *proto.ColUInt128
	nullCol  *proto.ColNullable[proto.UInt128]
	nullable bool
}

var _ InsaneColInput = (*ColUInt128)(nil)

func NewColUInt128(nullable bool) *ColUInt128 {
	return &ColUInt128{
		col:      &proto.ColUInt128{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[proto.UInt128](&proto.ColUInt128{})),
		nullable: nullable,
	}
}

func (t *ColUInt128) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[proto.UInt128]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := proto.UInt128FromInt(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColUInt128) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColUInt128) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColUInt128) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColUInt128) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColUInt256 struct {
	col      *proto.ColUInt256
	nullCol  *proto.ColNullable[proto.UInt256]
	nullable bool
}

var _ InsaneColInput = (*ColUInt256)(nil)

func NewColUInt256(nullable bool) *ColUInt256 {
	return &ColUInt256{
		col:      &proto.ColUInt256{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[proto.UInt256](&proto.ColUInt256{})),
		nullable: nullable,
	}
}

func (t *ColUInt256) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[proto.UInt256]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := proto.UInt256FromInt(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColUInt256) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColUInt256) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColUInt256) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColUInt256) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColFloat32 struct {
	col      *proto.ColFloat32
	nullCol  *proto.ColNullable[float32]
	nullable bool
}

var _ InsaneColInput = (*ColFloat32)(nil)

func NewColFloat32(nullable bool) *ColFloat32 {
	return &ColFloat32{
		col:      &proto.ColFloat32{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[float32](&proto.ColFloat32{})),
		nullable: nullable,
	}
}

func (t *ColFloat32) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[float32]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := float32(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColFloat32) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColFloat32) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColFloat32) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColFloat32) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}

type ColFloat64 struct {
	col      *proto.ColFloat64
	nullCol  *proto.ColNullable[float64]
	nullable bool
}

var _ InsaneColInput = (*ColFloat64)(nil)

func NewColFloat64(nullable bool) *ColFloat64 {
	return &ColFloat64{
		col:      &proto.ColFloat64{},
		nullCol:  proto.NewColNullable(proto.ColumnOf[float64](&proto.ColFloat64{})),
		nullable: nullable,
	}
}

func (t *ColFloat64) Append(node *insaneJSON.StrictNode) error {
	if node.IsNil() || node.IsNull() {
		if !t.nullable {
			return ErrNodeIsNil
		}
		t.nullCol.Append(proto.Null[float64]())
		return nil
	}
	v, err := node.AsInt()
	if err != nil {
		return err
	}
	val := float64(v)
	if t.nullable {
		t.nullCol.Append(proto.NewNullable(val))
		return nil
	}
	t.col.Append(val)

	return nil
}

func (t *ColFloat64) Reset() {
	t.col.Reset()
	t.nullCol.Reset()
}

func (t *ColFloat64) Type() proto.ColumnType {
	if t.nullable {
		return t.nullCol.Type()
	}
	return t.col.Type()
}

func (t *ColFloat64) Rows() int {
	if t.nullable {
		return t.nullCol.Rows()
	}
	return t.col.Rows()
}

func (t *ColFloat64) EncodeColumn(buffer *proto.Buffer) {
	if t.nullable {
		t.nullCol.EncodeColumn(buffer)
		return
	}
	t.col.EncodeColumn(buffer)
}
